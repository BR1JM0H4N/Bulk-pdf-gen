<!doctype html>
<html lang="en">
<head>
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>
  eruda.init();
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mobile PDF Editor — Add Text & Live Preview</title>
  <style>
    :root{
      --accent:#0b76ef;
      --bg:#0f1724;
      --card:#0b1220;
      --muted:#9aa4b2;
      --radius:12px;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,#071024 0%, #0b1220 100%);color:#e6eef6;padding:12px;box-sizing:border-box}
    .app{max-width:900px;margin:0 auto;display:flex;flex-direction:column;gap:12px}

    /* Header */
    header{display:flex;gap:8px;align-items:center;justify-content:space-between}
    h1{font-size:16px;margin:0}
    .controls{display:flex;gap:8px;align-items:center}

    /* Canvas area */
    .preview-card{background:linear-gradient(180deg,#081427,#071122);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:10px}
    .viewport{position:relative;width:100%;max-width:420px;margin:0 auto}
    canvas{width:100%;height:auto;border-radius:8px;display:block}
    .overlay{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}

    /* Text UI */
    .toolbar{display:flex;gap:6px;flex-wrap:wrap}
    button,select,input[type=number]{background:var(--card);border:1px solid rgba(255,255,255,0.03);color:var(--muted);padding:8px;border-radius:8px}
    input[type=file]{display:none}
    .file-label{padding:8px 12px;background:var(--accent);color:#fff;border-radius:10px;font-weight:600}

    /* Item list */
    .items{display:flex;flex-direction:column;gap:8px;margin-top:8px}
    .item{background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
    .item-left{display:flex;flex-direction:column;gap:6px}
    label{font-size:12px;color:var(--muted)}
    .small{font-size:13px}

    /* mobile optimization */
    @media (max-width:480px){
      .app{padding:8px}
      header{gap:6px}
      .viewport{max-width:360px}
      .item{grid-template-columns:1fr}
    }

    /* draggable text preview boxes (on top of preview canvas) */
    .txt-box{position:absolute;pointer-events:auto;cursor:grab;user-select:none;padding:2px 6px;border-radius:6px;white-space:nowrap}
    .txt-box:active{cursor:grabbing}

    .muted-small{font-size:12px;color:var(--muted)}
    .footer{display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:8px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Mobile PDF Editor — Add Text & Live Preview</h1>
      <div class="controls">
        <label class="file-label" for="file">Select PDF</label>
        <input id="file" type="file" accept="application/pdf" />
        <button id="addTextBtn">+ Add Text</button>
        <button id="exportBtn">Export PDF</button>
      </div>
    </header>

    <div class="preview-card">
      <div class="viewport" id="viewport">
        <canvas id="pdfCanvas"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
      <div class="muted-small">Live preview uses the <strong>first page</strong> of the chosen PDF. Controls below edit each added text box. Position inputs (x,y) are in pixels relative to the preview.</div>

      <div class="items" id="items"></div>
      <div class="footer">
        <div class="muted-small">Tip: drag a text box on the preview to update X/Y quickly.</div>
        <div class="muted-small">Anchor affects how the X value is interpreted (left/center/right).</div>
      </div>
    </div>

  </div>

  <!-- Libraries: pdf.js and pdf-lib -->
  <script src="https://unpkg.com/pdfjs-dist/build/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script>
    // PDF.js worker config
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist/build/pdf.worker.min.js';

    // Elements
    const fileInput = document.getElementById('file');
    const pdfCanvas = document.getElementById('pdfCanvas');
    const overlay = document.getElementById('overlay');
    const addTextBtn = document.getElementById('addTextBtn');
    const itemsContainer = document.getElementById('items');
    const exportBtn = document.getElementById('exportBtn');
    const viewport = document.getElementById('viewport');

    let pdfDoc = null;
    let pageViewport = null; // pdf.js viewport used for preview
    let currentScale = 1;
    let textItems = []; // {id, text, fontSize, color, x, y, anchor}
    let nextId = 1;

    // Helpers
    function createTextElement(item){
      const el = document.createElement('div');
      el.className = 'txt-box';
      el.dataset.id = item.id;
      el.style.fontSize = item.fontSize + 'px';
      el.style.color = item.color;
      el.style.left = item.x + 'px';
      el.style.top = item.y + 'px';
      el.style.pointerEvents = 'auto';
      el.style.fontWeight = 600;
      el.style.background = 'rgba(255,255,255,0.02)';
      el.style.border = '1px dashed rgba(255,255,255,0.04)';
      el.style.textAlign = item.anchor === 'center' ? 'center' : item.anchor === 'right' ? 'right' : 'left';
      el.textContent = item.text || 'Text';

      // Drag to move
      let dragging = false;
      let startX, startY, origX, origY;
      el.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        dragging = true;
        el.setPointerCapture(ev.pointerId);
        startX = ev.clientX; startY = ev.clientY;
        origX = item.x; origY = item.y;
      });
      window.addEventListener('pointermove', (ev)=>{
        if(!dragging) return;
        const dx = ev.clientX - startX; const dy = ev.clientY - startY;
        const newX = Math.max(0, Math.min(viewport.clientWidth - 4, origX + dx));
        const newY = Math.max(0, Math.min(viewport.clientHeight - 4, origY + dy));
        item.x = newX; item.y = newY;
        el.style.left = item.x + 'px'; el.style.top = item.y + 'px';
        updateItemControls(item.id, {x: Math.round(item.x), y: Math.round(item.y)});
      });
      window.addEventListener('pointerup', ()=>{ if(dragging) dragging=false; });

      return el;
    }

    function renderOverlay(){
      overlay.innerHTML = '';
      textItems.forEach(it=>{
        const el = createTextElement(it);
        overlay.appendChild(el);
      });
    }

    function addTextItem(defaults){
      const item = Object.assign({id: nextId++, text:'New text', fontSize:18, color:'#ffffff', x:10, y:10, anchor:'left'}, defaults||{});
      textItems.push(item);
      renderItemControls(item);
      renderOverlay();
    }

    function renderItemControls(item){
      const wrap = document.createElement('div');
      wrap.className = 'item';
      wrap.id = 'item-'+item.id;

      const left = document.createElement('div'); left.className='item-left';
      // text
      const txLabel = document.createElement('label'); txLabel.textContent='Text';
      const txInput = document.createElement('input'); txInput.type='text'; txInput.value=item.text; txInput.className='small';
      txInput.addEventListener('input',()=>{ item.text = txInput.value; refreshItem(item.id); });
      // font size
      const fsLabel = document.createElement('label'); fsLabel.textContent='Font size (px)';
      const fsInput = document.createElement('input'); fsInput.type='number'; fsInput.min=6; fsInput.max=200; fsInput.value=item.fontSize; fsInput.className='small';
      fsInput.addEventListener('input',()=>{ item.fontSize = Number(fsInput.value); refreshItem(item.id); });
      // color
      const cLabel = document.createElement('label'); cLabel.textContent='Color';
      const cInput = document.createElement('input'); cInput.type='color'; cInput.value=item.color; cInput.className='small';
      cInput.addEventListener('input',()=>{ item.color = cInput.value; refreshItem(item.id); });

      left.appendChild(txLabel); left.appendChild(txInput);
      left.appendChild(fsLabel); left.appendChild(fsInput);
      left.appendChild(cLabel); left.appendChild(cInput);

      const right = document.createElement('div'); right.style.display='flex'; right.style.flexDirection='column'; right.style.gap='6px';
      // x,y inputs
      const xyWrap = document.createElement('div'); xyWrap.style.display='flex'; xyWrap.style.gap='6px';
      const xInput = document.createElement('input'); xInput.type='number'; xInput.value=item.x; xInput.style.width='80px';
      const yInput = document.createElement('input'); yInput.type='number'; yInput.value=item.y; yInput.style.width='80px';
      xInput.addEventListener('input',()=>{ item.x = Number(xInput.value); refreshItem(item.id); });
      yInput.addEventListener('input',()=>{ item.y = Number(yInput.value); refreshItem(item.id); });
      xyWrap.appendChild(document.createElement('label'));
      xyWrap.appendChild(xInput); xyWrap.appendChild(yInput);

      // anchor
      const anchor = document.createElement('select'); ['left','center','right'].forEach(a=>{ const o=document.createElement('option'); o.value=a; o.textContent=a; anchor.appendChild(o); });
      anchor.value = item.anchor;
      anchor.addEventListener('change',()=>{ item.anchor = anchor.value; refreshItem(item.id); });

      // delete
      const delBtn = document.createElement('button'); delBtn.textContent='Delete'; delBtn.addEventListener('click',()=>{ textItems = textItems.filter(t=>t.id!==item.id); const dom = document.getElementById('item-'+item.id); if(dom) dom.remove(); renderOverlay(); });

      right.appendChild(xyWrap);
      right.appendChild(anchor);
      right.appendChild(delBtn);

      wrap.appendChild(left); wrap.appendChild(right);

      itemsContainer.appendChild(wrap);

      // expose a small helper to update numeric inputs when drag occurs
      wrap._controls = {xInput,yInput,txInput,fsInput,cInput,anchor};
    }

    function updateItemControls(id, updates){
      const wrap = document.getElementById('item-'+id);
      if(!wrap || !wrap._controls) return;
      if('x' in updates) wrap._controls.xInput.value = updates.x;
      if('y' in updates) wrap._controls.yInput.value = updates.y;
      if('text' in updates) wrap._controls.txInput.value = updates.text;
      if('fontSize' in updates) wrap._controls.fsInput.value = updates.fontSize;
      if('color' in updates) wrap._controls.cInput.value = updates.color;
      if('anchor' in updates) wrap._controls.anchor.value = updates.anchor;
    }

    function refreshItem(id){
      const item = textItems.find(t=>t.id===id);
      if(!item) return;
      // update overlay element
      const el = overlay.querySelector(`[data-id='${id}']`);
      if(el){
        el.textContent = item.text;
        el.style.fontSize = item.fontSize + 'px';
        el.style.color = item.color;
        el.style.left = item.x + 'px';
        el.style.top = item.y + 'px';
        el.style.textAlign = item.anchor === 'center' ? 'center' : item.anchor === 'right' ? 'right' : 'left';
      }
    }

    // add text button
    addTextBtn.addEventListener('click', ()=> addTextItem());

    // handle file selection & render first page to canvas
    fileInput.addEventListener('change', async (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      const arr = await f.arrayBuffer();
      pdfDoc = await pdfjsLib.getDocument({data:arr}).promise;
      // render first page
      const page = await pdfDoc.getPage(1);
      const desiredWidth = Math.min(420, window.innerWidth - 24);
      const unscaledViewport = page.getViewport({scale:1});
      currentScale = desiredWidth / unscaledViewport.width;
      pageViewport = page.getViewport({scale: currentScale});

      // set canvas logical size to the viewport size in pixels
      const canvas = pdfCanvas;
      const context = canvas.getContext('2d');
      canvas.width = pageViewport.width;
      canvas.height = pageViewport.height;
      canvas.style.width = pageViewport.width + 'px';
      canvas.style.height = pageViewport.height + 'px';
      viewport.style.width = pageViewport.width + 'px';
      viewport.style.height = pageViewport.height + 'px';

      const renderContext = {canvasContext: context, viewport: pageViewport};
      await page.render(renderContext).promise;

      // clear previous items
      overlay.style.width = canvas.style.width; overlay.style.height = canvas.style.height;
      overlay.innerHTML = '';
      textItems = []; itemsContainer.innerHTML = '';
      nextId = 1;
    });

    // Export PDF using pdf-lib: draw each text item onto first page
    exportBtn.addEventListener('click', async ()=>{
      if(!pdfDoc){ alert('Load a PDF first'); return; }
      // load original bytes
      const file = fileInput.files[0];
      if(!file) return;
      const bytes = await file.arrayBuffer();
      const pdfLibDoc = await PDFLib.PDFDocument.load(bytes);
      const pages = pdfLibDoc.getPages();
      const first = pages[0];
      const {width: pdfWidth, height: pdfHeight} = first.getSize();

      // Map canvas pixels -> PDF points
      const canvasW = pdfCanvas.width; const canvasH = pdfCanvas.height;

      // Use a standard font
      const helvetica = await pdfLibDoc.embedFont(PDFLib.StandardFonts.Helvetica);

      for(const it of textItems){
        const xRatio = it.x / canvasW; // 0..1
        const yRatio = it.y / canvasH; // 0..1 (top)
        let pdfX = xRatio * pdfWidth;
        // anchor handling (left/center/right) approximate using text width
        const fontSize = it.fontSize;
        const textWidth = helvetica.widthOfTextAtSize(it.text||'', fontSize);
        if(it.anchor === 'center') pdfX = pdfX - textWidth/2;
        if(it.anchor === 'right') pdfX = pdfX - textWidth;
        // pdf y uses bottom-left origin
        const pdfY = pdfHeight - (yRatio * pdfHeight) - fontSize; // subtract font size to align top

        first.drawText(it.text||'', {
          x: pdfX,
          y: pdfY,
          size: fontSize,
          font: helvetica,
          color: PDFLib.rgb(parseInt(it.color.slice(1,3),16)/255, parseInt(it.color.slice(3,5),16)/255, parseInt(it.color.slice(5,7),16)/255),
        });
      }

      const newBytes = await pdfLibDoc.save();
      // download
      const blob = new Blob([newBytes], {type:'application/pdf'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'edited.pdf'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    // small utility to keep sync when drag updates controls
    function refreshItemControlsFromModel(){
      textItems.forEach(it=> updateItemControls(it.id, {x:Math.round(it.x), y:Math.round(it.y)}));
    }

    // Make sure overlay resizes with canvas on orientation change
    window.addEventListener('resize', ()=>{
      // if a pdf is loaded, re-render with new width
      if(!pdfDoc) return;
      // re-trigger file load behavior by re-rendering first page
      (async()=>{
        const page = await pdfDoc.getPage(1);
        const desiredWidth = Math.min(420, window.innerWidth - 24);
        const unscaledViewport = page.getViewport({scale:1});
        currentScale = desiredWidth / unscaledViewport.width;
        pageViewport = page.getViewport({scale: currentScale});
        const canvas = pdfCanvas; const ctx = canvas.getContext('2d');
        canvas.width = pageViewport.width; canvas.height = pageViewport.height;
        canvas.style.width = pageViewport.width + 'px'; canvas.style.height = pageViewport.height + 'px';
        viewport.style.width = pageViewport.width + 'px'; viewport.style.height = pageViewport.height + 'px';
        await page.render({canvasContext: ctx, viewport: pageViewport}).promise;
        overlay.style.width = canvas.style.width; overlay.style.height = canvas.style.height;
        // scale existing item positions proportionally
        // (simple approach: keep same pixel offsets)
        renderOverlay();
      })();
    });

    // When items are added/controls changed we should update overlay
    // Hook into mutation by periodically syncing (simple, robust)
    setInterval(()=>{
      textItems.forEach(it=> refreshItem(it.id));
      refreshItemControlsFromModel();
    }, 300);

  </script>
</body>
</html>
